-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package main

module Data.FAlgebra
class FAlgebra f a | a -> f
alg :: FAlgebra f a => f a -> a
class FCoalgebra f a | a -> f
coalg :: FCoalgebra f a => a -> f a
data Fix f
Fix :: f (Fix f) -> Fix f
unFix :: Fix f -> f (Fix f)
newtype Wrapped f a
Wrap :: f a -> Wrapped f a
unwrap :: Wrapped f a -> f a
newtype BFix f a
WrapBFix :: Fix (f a) -> BFix f a
unwrapBFix :: BFix f a -> Fix (f a)
data FreeF f a r
Pure :: a -> FreeF f a r
Free :: (f r) -> FreeF f a r
data CofreeF f a r
(:<) :: a -> (f r) -> CofreeF f a r
newtype Free f a
WrapFree :: Fix (FreeF f a) -> Free f a
unwrapFree :: Free f a -> Fix (FreeF f a)
newtype Cofree f a
WrapCofree :: Fix (CofreeF f a) -> Cofree f a
unwrapCofree :: Cofree f a -> Fix (CofreeF f a)
data AnnT f a f' r
AnnT :: a -> (f' (f r)) -> AnnT f a f' r
annFst :: AnnT t t1 t2 t3 -> t1
annSnd :: AnnT t t1 t2 t3 -> t2 (t t3)
newtype FIdentity (f :: * -> *) a
FIdentity :: a -> FIdentity a
runFIdentity :: FIdentity a -> a
type AnnF f a = AnnT f a (FIdentity f)
class FAlgebraFunctor f g | g -> f
algf :: (FAlgebraFunctor f g, FAlgebra f r) => f (g r) -> g r
data AnnFix f
AnnFix :: f (AnnFix f) -> AnnFix f
unAnnFix :: AnnFix f -> f (AnnFix f)
newtype Ann f a
Ann :: Cofree f a -> Ann f a
unAnn :: Ann f a -> Cofree f a
data ListF a r
N :: ListF a r
C :: a -> r -> ListF a r
type List a = BFix ListF a
cons :: FAlgebra (ListF a) t => a -> t -> t
nil :: List a
data Pair a
Pair :: a -> a -> Pair a
data TreeF a b
Empty :: TreeF a b
Branch :: a -> b -> b -> TreeF a b
type Tree a = BFix TreeF a
branch :: FAlgebra (TreeF a) t => a -> t -> t -> t
leaf :: FAlgebra (TreeF a) t => a -> t
empty :: FAlgebra (TreeF a) t => t
newtype Size a
Size :: Int -> Size a
type SizeTree a = Ann (TreeF a) (Size a)
newtype Combined a
Combined :: a -> Combined a
type CombinedTree a = Ann (TreeF a) (Combined a)
type SizeAndCombinedTree a = Ann (TreeF a) (Size a, Combined a)
type SizeTree2 a = AnnFix (AnnF (TreeF a) (Size a))
type SizeAndCombinedTree2 a = AnnFix (AnnT (TreeF a) (Combined a) (AnnT (TreeF a) (Size a) (FIdentity (TreeF a))))
instance Functor f => Functor (Ann f)
instance Show (Cofree f a) => Show (Ann f a)
instance Show (f (AnnFix f)) => Show (AnnFix f)
instance Show (Fix (CofreeF f a)) => Show (Cofree f a)
instance Show (Fix (FreeF f a)) => Show (Free f a)
instance Show (Fix (f a)) => Show (BFix f a)
instance Eq (Fix (f a)) => Eq (BFix f a)
instance Show (f (Fix f)) => Show (Fix f)
instance Eq (f (Fix f)) => Eq (Fix f)
instance Eq (f a) => Eq (Wrapped f a)
instance Show (f a) => Show (Wrapped f a)
instance (Eq a, Eq (f r)) => Eq (FreeF f a r)
instance (Show a, Show (f r)) => Show (FreeF f a r)
instance (Ord a, Ord (f r)) => Ord (FreeF f a r)
instance (Eq a, Eq (f r)) => Eq (CofreeF f a r)
instance (Show a, Show (f r)) => Show (CofreeF f a r)
instance (Ord a, Ord (f r)) => Ord (CofreeF f a r)
instance (Eq a, Eq (f' (f r))) => Eq (AnnT f a f' r)
instance (Show a, Show (f' (f r))) => Show (AnnT f a f' r)
instance Eq a => Eq (FIdentity f a)
instance Show a => Show (FIdentity f a)
instance Ord a => Ord (FIdentity f a)
instance (Eq a, Eq r) => Eq (ListF a r)
instance (Show a, Show r) => Show (ListF a r)
instance (Ord a, Ord r) => Ord (ListF a r)
instance Functor (ListF a)
instance Eq a => Eq (Pair a)
instance Show a => Show (Pair a)
instance Ord a => Ord (Pair a)
instance Functor Pair
instance (Eq a, Eq b) => Eq (TreeF a b)
instance (Show a, Show b) => Show (TreeF a b)
instance (Ord a, Ord b) => Ord (TreeF a b)
instance Functor (TreeF a)
instance Eq (Size a)
instance Show (Size a)
instance Ord (Size a)
instance Num (Size a)
instance Eq a => Eq (Combined a)
instance Show a => Show (Combined a)
instance Ord a => Ord (Combined a)
instance Num a => Num (Combined a)
instance Monoid a => FAlgebra (TreeF a) (Combined a)
instance FAlgebra (TreeF a) (Size a)
instance Bifunctor TreeF
instance Bifunctor ListF
instance Functor f => FCoalgebra f (Ann f a)
instance (Functor f, FAlgebra f a) => FAlgebra f (Ann f a)
instance Functor f => Comonad (Ann f)
instance (Functor f, FAlgebraFunctor f g) => FAlgebra f (AnnFix g)
instance Functor f => FAlgebraFunctor f (FIdentity f)
instance (Functor f, Functor f', FAlgebra f a, FAlgebraFunctor f f') => FAlgebraFunctor f (AnnT f a f')
instance (Functor f, FAlgebra f a, FAlgebra f (f' (f r))) => FAlgebra f (AnnT f a f' r)
instance (Functor f, FCoalgebra f a) => FCoalgebra f (FIdentity f a)
instance (Functor f, FAlgebra f a) => FAlgebra f (FIdentity f a)
instance Functor (FIdentity f)
instance (Functor f, Functor f') => Functor (AnnT f a f')
instance Functor f => Comonad (Cofree f)
instance Functor f => Functor (Cofree f)
instance Functor f => Applicative (Free f)
instance Functor f => Monad (Free f)
instance Functor f => Functor (Free f)
instance Functor f => FCoalgebra (CofreeF f a) (Cofree f a)
instance Functor f => FCoalgebra (FreeF f a) (Free f a)
instance Functor f => FAlgebra (CofreeF f a) (Cofree f a)
instance Functor f => FAlgebra (FreeF f a) (Free f a)
instance Functor f => Functor (CofreeF f a)
instance Functor f => Bifunctor (CofreeF f)
instance Functor f => Functor (FreeF f a)
instance Functor f => Bifunctor (FreeF f)
instance Bifunctor f => Functor (BFix f)
instance Functor (f a) => FCoalgebra (f a) (BFix f a)
instance Functor (f a) => FAlgebra (f a) (BFix f a)
instance (Functor f, FCoalgebra f a1, FCoalgebra f a2) => FCoalgebra f (Either a1 a2)
instance (Functor f, FAlgebra f a1, FAlgebra f a2) => FAlgebra f (a1, a2)
instance (Functor f, FCoalgebra f a) => FCoalgebra f (Identity a)
instance (Functor f, FAlgebra f a) => FAlgebra f (Identity a)
instance (Functor f, FCoalgebra f a) => FCoalgebra f (Wrapped f a)
instance (Functor f, FAlgebra f a) => FAlgebra f (Wrapped f a)
instance Functor f => Functor (Wrapped f)
instance FCoalgebra f (Fix f)
instance FAlgebra f (Fix f)
